/*
Rygr Async Queue, v 1.0.0
Copyright (c)2014 Patrick Camacho
Distributed under MIT license
https://github.com/camacho/rygr.async-queue
 */
(function(){var e;e=function(e){var n,r;if(!e)throw new ReferrenceError("Promise library is not defined");return n=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},r=function(e){return"function"==typeof e},function(t,o,i){var f,u,a,c,d,l,s;if(d=[],a=(e.defer||e.Deferred)(),n(t)||(t=[t]),f=t.length+1,!n(o)){if(!r(o))throw new Error("Callbacks must be an array of functions");o=[o]}for(l=0,s=o.length;s>l;l++){if(u=o[l],!r(u))throw new Error("Callback is not a function");d.push({handle:u})}return c=function(){var n,r;return n=0,(r=function(o){var u,c,l;if(("function"==typeof e.isPending?e.isPending(a.promise):0)||"pending"===a.state()){if(l=d[n++],!l)return o?a.reject(o):a.resolve(),void("function"==typeof i&&i(o));try{return u=l.handle.length,o?u===f+1?l.handle.apply(void 0,[o].concat(t,[r])):r(o):f+1>u?l.handle.apply(void 0,t.concat([r])):r()}catch(s){return c=s,r(c)}}})()},c(),a.promise}},function(e,n){var r,t;return t="jquery","function"==typeof define&&define.amd?define([t],function(e){return n(e)}):"undefined"!=typeof exports?(r=n(require(t)),"undefined"!=typeof module&&module.exports?module.exports=r:exports.AsyncQueue=r):e.AsyncQueue=n(e[t])}(this,e)}).call(this);